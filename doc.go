// chris 080715

// govalid generates validation code for maps of strings to strings to
// marshal the data into well-typed structures.
//
// Command-line invocation is as follows.
//
//	usage: govalid [-h] [-o file.go] [file.v]
//	  -o="": output file name
//
//
// If no input file is specified as a positional argument, govalid reads
// from standard in.  If no output file is specified and reading from
// standard in, output will be written to standard out.  Otherwise,
// output will be written to the a path generated by replacing the input
// path extension with ".go".
//
// The generated code abides by gofmt.  It leverages strconv.Parse,
// net/mail.ParseAddress, and net/url.Parse.
//
// Usage
//
// govalid is meant to be used with go generate.  In your project, you
// write .v files, which are valid Go files that define structure types
// into which you want to marshal input data.  Here is an example of a
// .v file.
//
//	package worker
//
//	type jobInput struct {
//		jobid int
//		nodeBlock bool
//		destination string
//		language string
//	}
//
// Given this input file, govalid will generate the following Go file.
//
// 	// *** GENERATED BY GOVALID; DO NOT EDIT ***
//
//	package worker
//
//	// *** strconv IMPORT ADDED BY GOVALID ***
//	import "strconv"
//
//	type jobInput struct {
//	        jobid       int
//	        nodeBlock   bool
//	        destination string
//	        language    string
//	}
//
//	// validateJobInput reads data from the given map of strings to
//	// strings and validates the data into a new *jobInput.
//	// Fields named in a jobInput will be recognized as keys.
//	// Keys in the input data that are not fields in the
//	// jobInput will be ignored.  If there is an error
//	// validating any fields, an appropriate error will
//	// be returned.
//	func validateJobInput(data map[string]string) (*jobInput, error) {
//	        ret := new(jobInput)
//	        var err error
//	        // jobid int
//	        var jobidtmp int64
//	        jobidtmp, err = strconv.ParseInt(data["jobid"], 0, 0)
//	        if err != nil {
//	                return nil, err
//	        }
//	        ret.jobid = int(jobidtmp)
//	        // nodeBlock bool
//	        ret.nodeBlock, err = strconv.ParseBool(data["nodeBlock"])
//	        if err != nil {
//	                return nil, err
//	        }
//	        // destination string
//	        ret.destination = data["destination"]
//	        // language string
//	        ret.language = data["language"]
//
//	        return ret, nil
//	}
//
// Look at all that code you didn't have to write.  govalid is meant to
// help you avoid having to write such boilerplate data validation code.
//
// Note that any fields not mentioned in the input structure will be
// ignored.
//
// Supported Types
//
//	string
//	bool
//	int
//	int8
//	int16
//	int32
//	int64
//	uint
//	uint8
//	uint16
//	uint32
//	uint64
//	float32
//	float64
//	*mail.Address
//	*url.URL
//
// Note that you will be responsible for importing net/mail or net/url
// in your .v file yourself.
//
// Integer Bases
//
// The generated validation code for ints and uints uses a base of 0,
// so input strings may be in any base represented by the
// strconv.ParseInt or strconv.ParseUint functions.  For example, a
// hexadecimal value would be parsed by passing in "0xbeef" or "48879".
//
// Export
//
// If your structure name indicates it is to be (un)exported, then the
// validation function will also be (un)exported.  For example, in the
// above sample, the validation function was unexported.  But if we had
// written out
//
//	type JobInput struct {
//		...
//
// instead, then our validation function would have had the following
// signature.
//
//	func ValidateJobInput(data map[string]string) (*jobInput, error) {
//		...
//
// Error Conditions
//
// If an input structure contains no validatable fields, then the
// generated code will declare an unused err variable, which will cause
// a compile error.  This is currently considered a feature, although
// future use cases may require a more general handling of such
// ill-advised inputs to avoid generating bad code.
package main
