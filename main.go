// chris 071415

package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path"
	"strings"

	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
)

var args struct {
	// Program name variables.  Set by init.
	prog      string
	progUpper string

	// Source and destination file names.  Can be "-" for stdin/out.
	srcname string
	dstname string
}

// process parses the source, finds struct definitions, and invokes the
// validator code to produce validators for the struct definitions.  It
// prints the original code plus the generated code to the given
// destination writer.
func process(dst io.Writer, srcname string, src io.Reader) error {
	// Parse first before outputting anything.
	fset := token.NewFileSet()
	mode := parser.DeclarationErrors | parser.AllErrors
	astfile, err := parser.ParseFile(fset, srcname, src, mode)
	if err != nil {
		return err
	}

	// Buffer validator function code before outputting anything.
	// We do this because we need to know whether we need to augment
	// the import list before outputting any declarations (imports
	// must precede declarations).
	buf := new(bytes.Buffer)

	needsStrconv := false

	// Isolate the struct types--the things for which we want to
	// generate validator functions.
	for _, obj := range astfile.Scope.Objects {
		if obj.Kind != ast.Typ {
			continue
		}
		ts, ok := obj.Decl.(*ast.TypeSpec)
		if !ok {
			continue
		}
		s, ok := ts.Type.(*ast.StructType)
		if !ok {
			continue
		}
		if s.Fields == nil {
			return fmt.Errorf("type %s struct has empty field list %v", ts.Name, ts)
		}

		// Ok, we isolated the struct type, now output a
		// validator for it.
		if validator(buf, ts.Name.Name, s) {
			needsStrconv = true
		}
	}

	// Add strconv import if needed.  Also, make more generic if
	// need be.  (E.g., adding other imports besides strconv, doing
	// non-linear search through existing imports, etc.)
	if needsStrconv && !hasImport(astfile, "strconv") {
		prependImport(astfile, "strconv")
	}

	// Output header comment.
	_, err = io.WriteString(dst, fmt.Sprintf("// *** GENERATED BY %s; DO NOT EDIT ***\n\n", args.progUpper))
	if err != nil {
		return err
	}

	// Next, output original code.
	err = printer.Fprint(dst, fset, astfile)
	if err != nil {
		return err
	}

	// Output generated code (from the buffer).
	io.Copy(dst, buf)

	return nil
}

func usage() {
	log.Printf("usage: %s [-h] [-o file.go] [file.v]", args.prog)
	flag.PrintDefaults()
	os.Exit(2)
}

func init() {
	args.prog      = path.Base(os.Args[0])
	args.progUpper = strings.ToUpper(args.prog)
	log.SetFlags(0)
	flag.Usage = usage
	dstname := flag.String("o", "", "output file name")
	flag.Parse()

	if len(flag.Args()) == 0 {
		args.srcname = "-"
	} else if len(flag.Args()) == 1 {
		args.srcname = flag.Args()[0]
	} else {
		usage()
	}

	args.dstname = *dstname
}

func main() {
	var (
		src io.Reader
		dst io.Writer
	)

	if args.srcname == "-" {
		src = os.Stdin
	} else {
		file, err := os.Open(args.srcname)
		if err != nil {
			log.Fatal(err)
		}
		defer file.Close()
		src = file
	}

	if args.dstname == "" {
		// Need to determine where output will go based on the
		// source.
		if args.srcname == "-" {
			args.dstname = "-"
		} else {
			// Chop off srcname extension and replace it
			// with ".go".
			srcext := path.Ext(args.srcname)
			args.dstname = fmt.Sprintf("%s.go", args.srcname[:len(args.srcname)-len(srcext)])
		}
	}

	if args.dstname == "-" {
		dst = os.Stdout
	} else {
		flag := os.O_WRONLY | os.O_CREATE | os.O_TRUNC
		file, err := os.OpenFile(args.dstname, flag, 0666)
		if err != nil {
			log.Fatal(err)
		}
		defer file.Close()
		dst = file
	}

	if err := process(dst, args.srcname, src); err != nil {
		log.Fatal(err)
	}
}
