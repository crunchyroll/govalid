// *** GENERATED BY GOVALID; DO NOT EDIT ***

package main

// *** IMPORT ADDED BY GOVALID ***
import "strconv"

// *** IMPORT ADDED BY GOVALID ***
import "errors"

import (
	"net/http"
	"net/mail"

	"golang.org/x/crypto/bcrypt"
)

func getReqInput(req *http.Request) (map[string]string, error) {
	if err := req.ParseForm(); err != nil {
		return nil, err
	}
	v := req.Form
	r := make(map[string]string, len(v))
	for k, vs := range v {
		r[k] = vs[0]
	}
	return r, nil
}

func hashPass(password string) ([]byte, error) {
	return bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
}

type userInput struct {
	username string `valid:"max:16"`
	password string `valid:"max:64"`

	fname string `valid:"max:128,def"`
	lname string `valid:"max:128,def"`

	email *mail.Address `valid:"max:1024"`

	age uint `valid:"min:13,max:200,def"`
}

type groupInput struct {
	name  string `valid:"max:16"`
	descr string `valid:"max:1024,def"`
}

// validateUserInput reads data from the given map of strings to
// strings and validates the data into a new *userInput.
// Fields named in a userInput will be recognized as keys.
// Keys in the input data that are not fields in the
// userInput will be ignored.  If there is an error
// validating any fields, an appropriate error will
// be returned.
func validateUserInput(data map[string]string) (*userInput, error) {
	ret := new(userInput)
	var (
		field_username string
		field_email_s  string
		err            error
		ok             bool
		field_password string
		field_fname    string
		field_lname    string
		field_age_s    string
		field_age      uint64
	)

	// username string
	field_username, ok = data["username"]
	if ok {
		if len(field_username) > 16 {
			return nil, errors.New("username can have a length of at most 16")
		}
		ret.username = field_username
	} else {
		return nil, errors.New("username is required")
	}

	// password string
	field_password, ok = data["password"]
	if ok {
		if len(field_password) > 64 {
			return nil, errors.New("password can have a length of at most 64")
		}
		ret.password = field_password
	} else {
		return nil, errors.New("password is required")
	}

	// fname string
	field_fname, ok = data["fname"]
	if ok {
		if len(field_fname) > 128 {
			return nil, errors.New("fname can have a length of at most 128")
		}
		ret.fname = field_fname
	} else {
		// fname is optional.
		// Zero value already set.
	}

	// lname string
	field_lname, ok = data["lname"]
	if ok {
		if len(field_lname) > 128 {
			return nil, errors.New("lname can have a length of at most 128")
		}
		ret.lname = field_lname
	} else {
		// lname is optional.
		// Zero value already set.
	}

	// email *mail.Address
	field_email_s, ok = data["email"]
	if ok {
		if len(data["email"]) > 1024 {
			return nil, errors.New("email can have a length of at most 1024")
		}
		ret.email, err = mail.ParseAddress(field_email_s)
		if err != nil {
			return nil, err
		}
	} else {
		return nil, errors.New("email is required")
	}

	// age uint
	field_age_s, ok = data["age"]
	if ok {
		field_age, err = strconv.ParseUint(field_age_s, 0, 0)
		if err != nil {
			return nil, err
		}
		if field_age > 200 {
			return nil, errors.New("age can be at most 200")
		}
		if field_age < 13 {
			return nil, errors.New("age must be at least 13")
		}
		ret.age = uint(field_age)
	} else {
		// age is optional.
		// Zero value already set.
	}

	return ret, nil
}

// validateGroupInput reads data from the given map of strings to
// strings and validates the data into a new *groupInput.
// Fields named in a groupInput will be recognized as keys.
// Keys in the input data that are not fields in the
// groupInput will be ignored.  If there is an error
// validating any fields, an appropriate error will
// be returned.
func validateGroupInput(data map[string]string) (*groupInput, error) {
	ret := new(groupInput)
	var (
		field_name  string
		ok          bool
		field_descr string
	)

	// name string
	field_name, ok = data["name"]
	if ok {
		if len(field_name) > 16 {
			return nil, errors.New("name can have a length of at most 16")
		}
		ret.name = field_name
	} else {
		return nil, errors.New("name is required")
	}

	// descr string
	field_descr, ok = data["descr"]
	if ok {
		if len(field_descr) > 1024 {
			return nil, errors.New("descr can have a length of at most 1024")
		}
		ret.descr = field_descr
	} else {
		// descr is optional.
		// Zero value already set.
	}

	return ret, nil
}
